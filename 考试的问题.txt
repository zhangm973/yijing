优点 
语法特点 
优势
生命周期  钩子函数 相对的意义
选项卡啊

子组件控制父组件来改变父组件的状态 


父传子用props  
子传父用回调函数
无关系组件通信的栗子
创建一个空对象

面试 
自我介绍完  HR没有问题  可以说‘’您可以看看我做的那个某某项目 然后转到项目上  避免说不上的尴尬



加班的目的
      有了工作后我们就有了任务，如果在我们工作时间里完成不了这些任务，就只得在工作时间以外完成，这就是加班。加班是一件很正常的事，无论从事什么职业，做什么工作，都存在着没法按时完成任务的可能。

对于IT行业来说，加班是一件很常见的事，主要原因大概有以下几点：
1.IT行业的本身行业发展很快，因此产品迭代速度也就很快，导致任务不确定性很高，经常临时更改需求增加了任务量；
2.IT行业中修改BUG的时间很难估计，也许BUG本身修改也许只要一分钟，但是准确找到这个BUG却要几天时间；
3.IT行业从事人员变动大，突然有一个人要离开团队，他的任务也就落在团队其他人身上了；
4.IT人员对产品的精益求精，一个产品从能实现到真正有实用价值，这还有很长一段路要走，这个任务量也是难以估计的。
      所以，其实我们可以看到加班并不是目的，加班只是个过程，加班的目的只是为了完成我们未完成的任务。
那么加班有价值么？其实我们做的每一件事都不可能毫无价值，但如果我们做某件事上付出的时间和自己的收获不成正比的话，那我姑且认为这件事是没价值的。

      因此，从这个角度上来讲，我认为加班对于除了刚入职的新人来说，真的没价值。

首先，让我们进步的不是工作，不是加班，而是学习

问我加班么，我当然加啦，毕竟我还要吃饭啊。但是我现在是尽量避免无意义的加班，比如拿到需求时候我会先和需求人员交流，避免因为理解不准确的原因造成返工；比如我拿到任务时候会先评估下，觉得时间不够会尽早和领导说明，否则加班不说，还容易因为自己完不成影响整个项目的进度；比如空余时间多看书，多学习，提高自己的能力，效率高了自然加班也就少了。

      最最最后，对于避免不了的加班，我们还是积极去面对吧。

加班的话题 http://blog.csdn.net/bit_kaki/article/details/77386903

在使用 React 来开发 SPA （单页应用）项目时，需要路由功能。

路由在访问一个新页面的时候仅仅是变换了一下路径而已，每个路由对应着一个组件，没有发送请求就没有了网络延迟，对于用户体验来说会有相当大的提升。

使用路由的时候需要用Router组件整个包起来 用Link组件中的to属性渲染出链接并且进行路由的跳转指向相应的路由，

Route 组件就是用于配置路由，用其中的path 属性配置路径，对应相应的组件。

路由中动态的内容不同 其他部分相同，可以使用path 属性中的 :id 就是该路由的参数（param）获取this.props.match.params.id

Swiper(Swiper master)是目前应用较广泛的移动端网页触摸内容滑动js插件。
Animate.css内置了很多典型的css3动画,兼容性好使用方便。

transition-property		规定设置过渡效果的 CSS 属性的名称。
transition-duration		规定完成过渡效果需要多少秒或毫秒。
transition-timing-function	规定速度效果的速度曲线。
transition-delay		定义过渡效果何时开始。

animation-name		规定需要绑定到选择器的 keyframe 名称。。
animation-duration	规定完成动画所花费的时间，以秒或毫秒计。
animation-timing-function	规定动画的速度曲线。
animation-delay		规定在动画开始之前的延迟。
animation-iteration-count	规定动画应该播放的次数。
animation-direction	规定是否应该轮流反向播放动画。

vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持.

引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。

this.$http.jsonp('url')在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。then方法的回调函数也有两种写法，第一种是传统的函数写法，第二种是更为简洁的ES 6的Lambda

this.$http.get('/someUrl', [options]).then(successCallback, errorCallback);
this.$http.post('/someUrl', [body], [options]).then(successCallback, errorCallback);

react组件之间的数据传输 
无关系组件 之间的传输 声明一个空的对象，然后用 

子组件控制父组件 props

具体的钩子函数：
实例化(调用组件)
    getDefaultProps  (设置默认的props)
    getInitialState  (设置默认的state)
    componentWillMount (组件第一次即将调用render)
    render  (渲染DOM)
    componentDidMount (render完成，在这里可以获取到真实的dom)

存在期(或调用setState)
    componentWillReceiveProps(当组件接收到新得props)
    shouldComponentUpdate(判断是否需要重新渲染)
    componentWillUpdate(组件重新渲染)即将调用render
    componentDidUpdate(组件重新渲染完成)

销毁期
    componentWillUnmount

react 组件就是一个个可组合的功能单元

闭包函数的优缺点

在JavaScript中，每个函数 都有一个prototype属性，当一个函数被用作构造函数来创建实例时，这个函数的prototype属性值会被作为原型赋值给所有对象实例（也就是设置 实例的`__proto__`属性），也就是说，所有实例的原型引用的是函数的prototype属性。

LESS具有以下明显的优点:
    (1).需要编写的代码量明显变少了。
    (2).CSS管理更加容易了.在需要更换网站样式风格时尤其如此,此时如果直接重写这些样式，工作量将非常浩大，但是用LESS就很简单,改个全局配置就可以了。
    (3).LESS学习成本不是很高，与CSS规则完全融合，如果用户熟悉CSS的话，那么只需要简单的学习，就能够快速驾驭LESS,
    (4).使用LESS实现配色变得非常容易。在传统设计中，用户需要借助配色工具或者图像编辑软件来实现色彩的搭配.不但效果不是很理想，而且还需要投人很大的精力。
    例如,在设计的时候,常常需要反复试验哪种颜色比较适合。虽然知道主色调要用原色，但是根据设计意图，可能需要深一点、浅一点、亮一点、暗一点，或者再带一点黄色,再带一点棕色,如此等等。如果每试一次都要改全套的样式，那么这个工作量是非常大的，
而且也不能够精确址化。现在，利用LESS的变址，结合颜色函数，所有配色问题就变得容易多了。在网站改版中也是如此。
    (5).兼容 CSS3。很多CSS3语法目前还需要为各个浏览器写特别的语法，如圆角、盒子阴影、变形、过渡等，如果把这些代码使用LESS先封装起来，使用时就会省事很多。
    (6).与CSS能够很好地融合使用。在LESS代码中可以融人CSS代码，在CSS代码中可以插人LESS语法。因此，对于用户来说,有了LESS,同样还需要继续学习CSS,还是需要会写CSS, LESS只是帮我们省下一些工夫，大部分样式还是要知道CSS是如何实现的,否则就不知道如何把LESS编译成为CSS.

localstorage 和sessionstorage和cookie  webstorage

sessionStorage使用方法完全同localStorage一致，不同之处：

1 localStorage:没有时间限制的数据存储,类似于cookie，一直存在，直到用户清除数据；

2 sessionStorage只针对一个 session 的数据存储，关闭当前网页/窗口就会消失；

与Cookie相比，Web Storage存在不少的优势，概括为以下几点：

存储空间更大：IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比Cookie要大很多。

存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送的服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本地，不会与服务器发生任何交互。

更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，使得数据操作更为简便。

独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。（因此每个域下都有10M的webStorage存储空间） 

同步和异步的区别 
盒子模型是什么
行内样式  
优雅降级和渐进增强  0.2的时候有一个方法0.3的时候废除了，（Jq的.live()方法）
